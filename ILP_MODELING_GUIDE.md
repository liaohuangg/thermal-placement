# ILP建模"有互联关系的方形需要相邻"的完整指南

## 问题描述

给定多个矩形（chiplets），每个矩形有宽度 `w_i` 和高度 `h_i`，以及它们之间的连接关系（边），要求：
1. **有互联关系的矩形必须相邻**
2. 最小化有互联关系的矩形外接圆圆心距离

## 方法一：方向性相邻约束（推荐）

### 变量定义

```python
# 连续变量
x_i: 矩形 i 的左下角 x 坐标
y_i: 矩形 i 的左下角 y 坐标

# 二进制变量
adjacent_{i,j,d}: 矩形 i 和 j 在方向 d 上相邻
其中 d ∈ {0, 1, 2, 3} 表示：
  - d=0: i 在 j 的左边（i 的右边界 = j 的左边界）
  - d=1: i 在 j 的右边（i 的左边界 = j 的右边界）
  - d=2: i 在 j 的下边（i 的上边界 = j 的下边界）
  - d=3: i 在 j 的上边（i 的下边界 = j 的上边界）
```

### 约束

#### 1. 相邻约束（核心约束）

对于所有有边连接的矩形对 `(i,j)`，必须至少在一个方向上相邻：

```
adjacent_{i,j,0} + adjacent_{i,j,1} + adjacent_{i,j,2} + adjacent_{i,j,3} >= 1
```

#### 2. 方向性约束

对于每个方向 `d`，如果 `adjacent_{i,j,d} = 1`，则需要满足对应的几何约束。

**示例：d=1（i 在 j 的右边）**

2.1 水平对齐约束：
```
x_i = x_j + w_j
```

使用 Big-M 线性化：
```
x_i >= x_j + w_j - M * (1 - adjacent_{i,j,1})
x_i <= x_j + w_j + M * (1 - adjacent_{i,j,1})
```

2.2 垂直重叠约束（确保两个矩形共享一条边）：
```
y_i <= y_j + h_j  且  y_j <= y_i + h_i
```

线性化：
```
y_i <= y_j + h_j + M * (1 - adjacent_{i,j,1})
y_j <= y_i + h_i + M * (1 - adjacent_{i,j,1})
y_i >= y_j - h_i - M * (1 - adjacent_{i,j,1})
y_j >= y_i - h_j - M * (1 - adjacent_{i,j,1})
```

**其他方向类似：**

- **d=0（i 在 j 左边）**：`x_i + w_i = x_j`，其余类似
- **d=2（i 在 j 下边）**：`y_i + h_i = y_j`，水平重叠
- **d=3（i 在 j 上边）**：`y_i = y_j + h_j`，水平重叠

#### 3. 互斥性约束

同一对矩形 `(i,j)` 最多只能在一个方向上相邻：

```
adjacent_{i,j,0} + adjacent_{i,j,1} + adjacent_{i,j,2} + adjacent_{i,j,3} <= 1
```

#### 4. 非重叠约束

对于所有矩形对 `(i,j)`（无论是否有连接），必须满足非重叠约束：

```
x_i + w_i <= x_j  OR  x_j + w_j <= x_i  OR
y_i + h_i <= y_j  OR  y_j + h_j <= y_i
```

使用二进制变量线性化（标准方法）：
```
引入二进制变量 z_{i,j,k} (k=0,1,2,3) 表示4种不重叠情况

x_i + w_i <= x_j + M * (1 - z_{i,j,0})
x_j + w_j <= x_i + M * (1 - z_{i,j,1})
y_i + h_i <= y_j + M * (1 - z_{i,j,2})
y_j + h_j <= y_i + M * (1 - z_{i,j,3})

z_{i,j,0} + z_{i,j,1} + z_{i,j,2} + z_{i,j,3} >= 1
```

### 目标函数

最小化有互联关系的矩形外接圆圆心距离：

```
minimize: Σ_{(i,j) ∈ edges} dist(cx_i, cy_i, cx_j, cy_j)
```

其中：
- `cx_i = x_i + w_i/2`（矩形 i 的中心 x 坐标）
- `cy_i = y_i + h_i/2`（矩形 i 的中心 y 坐标）

距离可以用曼哈顿距离近似：
```
dist ≈ |cx_i - cx_j| + |cy_i - cy_j|
```

绝对值线性化：
```
引入辅助变量 dx_{i,j}, dy_{i,j} ≥ 0

dx_{i,j} >= cx_i - cx_j
dx_{i,j} >= cx_j - cx_i
dy_{i,j} >= cy_i - cy_j
dy_{i,j} >= cy_j - cy_i

目标函数变为：Σ_{(i,j) ∈ edges} (dx_{i,j} + dy_{i,j})
```

## 方法二：距离阈值约束（简化版）

如果"相邻"的定义更灵活（中心距离小于阈值），可以用这种方法。

### 变量定义

```python
# 连续变量
cx_i, cy_i: 矩形 i 的中心坐标
dx_{i,j}, dy_{i,j}: 辅助变量，表示 |cx_i - cx_j| 和 |cy_i - cy_j|

# 二进制变量
adjacent_{i,j}: 矩形 i 和 j 是否相邻
```

### 约束

#### 1. 相邻约束

对于所有有边连接的矩形对 `(i,j)`：

```
adjacent_{i,j} = 1
```

#### 2. 距离约束

相邻时，中心距离必须小于阈值 `threshold`：

```
dx_{i,j} + dy_{i,j} <= threshold * adjacent_{i,j} + M * (1 - adjacent_{i,j})
```

或者更严格：
```
dx_{i,j} + dy_{i,j} <= threshold
```

#### 3. 绝对值线性化

```
dx_{i,j} >= cx_i - cx_j
dx_{i,j} >= cx_j - cx_i
dy_{i,j} >= cy_i - cy_j
dy_{i,j} >= cy_j - cy_i
```

#### 4. 中心坐标与左下角坐标的关系

```
cx_i = x_i + w_i / 2
cy_i = y_i + h_i / 2
```

### 目标函数

同样最小化中心距离：

```
minimize: Σ_{(i,j) ∈ edges} (dx_{i,j} + dy_{i,j})
```

## 方法三：网格离散化（适合小规模）

将空间划分为网格，每个矩形占据网格单元。

### 变量定义

```python
# 二进制变量
grid_{i,x,y}: 矩形 i 占据网格位置 (x,y)
adjacent_{i,j}: 矩形 i 和 j 是否相邻
```

### 约束

#### 1. 每个矩形占据指定数量的网格单元

```
Σ_{(x,y)} grid_{i,x,y} = w_i * h_i  (如果网格单元大小=1)
```

#### 2. 相邻约束

如果两个矩形在网格上共享边界，则相邻：

```
对于矩形 i 占据的每个网格 (x1,y1)：
  如果矩形 j 占据相邻网格 (x2,y2) 其中 (x2,y2) ∈ neighbors(x1,y1)
  则 adjacent_{i,j} = 1
```

其中 `neighbors(x1,y1)` 包括上下左右四个相邻网格。

线性化：
```
Σ_{(x1,y1) in grid_i} Σ_{(x2,y2) in neighbors(x1,y1)} grid_{j,x2,y2} >= adjacent_{i,j}
```

#### 3. 有边连接的矩形必须相邻

```
adjacent_{i,j} = 1  (对于所有 (i,j) ∈ edges)
```

## 复杂度分析

- **方法一（方向性相邻）**：
  - 变量数：O(n²) 个二进制变量（n 个矩形）
  - 约束数：O(n²) 
  - 优点：最严格的相邻定义，符合实际需求
  - 缺点：约束较多，求解可能较慢

- **方法二（距离阈值）**：
  - 变量数：O(n²)
  - 约束数：O(n²)
  - 优点：约束相对简单
  - 缺点：可能允许"对角相邻"，不够严格

- **方法三（网格离散化）**：
  - 变量数：O(n * grid_size)
  - 约束数：O(n * grid_size)
  - 优点：如果网格较小，约束较简单
  - 缺点：需要离散化，精度受限

## 推荐方案

对于芯片布局问题，推荐使用**方法一（方向性相邻约束）**，因为：
1. 最符合"相邻"的直观理解（共享边界）
2. 避免了"对角相邻"等不合理的解
3. 虽然约束较多，但现代ILP求解器（如Gurobi、CPLEX）可以处理

## 实现建议

1. 使用专业的ILP求解器（如 Gurobi、CPLEX、PuLP 等）
2. 如果问题规模较大，可以考虑：
   - 分层求解（先粗后细）
   - 启发式方法生成初始解
   - 分解方法（将问题分解为子问题）

## 示例代码

完整实现示例见 `src/ilp_method.py`。

