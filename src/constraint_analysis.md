# 排除解约束逻辑分析

## 问题：为什么只能搜索到1个解？

### 当前约束逻辑的错误

#### 错误1：约束逻辑矛盾

**当前代码（第205-214行）：**
```python
# 情况1：从水平相邻变为垂直相邻
if z1_ori >= 0.5:
    # 原解是水平相邻，新解必须是垂直相邻（z2 = 1）
    prob += z2_var >= pos_diff[(i, j)] - M * (1 - pos_diff[(i, j)])
```

**问题：**
- 如果原解是水平相邻（`z1_ori = 1`），根据硅桥互联的约束（`z1 + z2 = 1`），新解也必须是水平相邻（`z1_new = 1`），所以 `z2_new = 0`
- 但约束要求如果 `pos_diff = 1`，那么 `z2_var >= 1`，这与 `z2_new = 0` 矛盾！
- 这导致当 `pos_diff = 1` 时，约束无法满足，求解器找不到可行解

#### 错误2：约束逻辑不完整

**当前代码只考虑了两种情况：**
1. 从水平相邻变为垂直相邻（但这是不可能的，因为硅桥互联必须保持相邻）
2. 从垂直相邻变为水平相邻（同样不可能）

**但忽略了正确的情况：**
- 保持水平相邻，但改变方向（左↔右）
- 保持垂直相邻，但改变方向（上↔下）

#### 错误3：Big-M约束方向错误

**当前约束：**
```python
z2_var >= pos_diff[(i, j)] - M * (1 - pos_diff[(i, j)])
```

**分析：**
- 如果 `pos_diff = 1`：约束变成 `z2_var >= 1 - M * 0 = 1`，要求 `z2_var = 1`
- 如果 `pos_diff = 0`：约束变成 `z2_var >= 0 - M * 1 = -M`，总是满足

**问题：**
- 这个约束只在一个方向上起作用：如果 `pos_diff = 1`，强制 `z2 = 1`
- 但没有反向约束：如果 `z2 = 1`，不要求 `pos_diff = 1`
- 而且，这个约束与硅桥互联的基本约束（`z1 + z2 = 1`）矛盾

## 正确的约束逻辑

### 要求：
1. 硅桥互联的chiplet对必须保持相邻（`z1 + z2 = 1`）
2. 但相对位置必须改变：
   - 如果原解是水平相邻（`z1_ori = 1`），新解也必须是水平相邻（`z1_new = 1`），但方向必须改变（`z1L_ori != z1L_new` 或 `z1R_ori != z1R_new`）
   - 如果原解是垂直相邻（`z2_ori = 1`），新解也必须是垂直相邻（`z2_new = 1`），但方向必须改变（`z2D_ori != z2D_new` 或 `z2U_ori != z2U_new`）

### 正确的约束应该：

**对于水平相邻的情况（`z1_ori = 1`）：**
- 新解必须保持水平相邻：`z1_new = 1`（这由基本约束保证）
- 方向必须改变：`z1L_new != z1L_ori` 或 `z1R_new != z1R_ori`
- 使用Big-M约束：
  - 如果 `pos_diff = 1`，那么 `z1L_new != z1L_ori` 或 `z1R_new != z1R_ori`
  - 具体：如果 `z1L_ori = 1`，那么 `z1R_new = 1`（从左变右）
  - 如果 `z1R_ori = 1`，那么 `z1L_new = 1`（从右变左）

**对于垂直相邻的情况（`z2_ori = 1`）：**
- 新解必须保持垂直相邻：`z2_new = 1`（这由基本约束保证）
- 方向必须改变：`z2D_new != z2D_ori` 或 `z2U_new != z2U_ori`
- 使用Big-M约束：
  - 如果 `pos_diff = 1`，那么 `z2D_new != z2D_ori` 或 `z2U_new != z2U_ori`
  - 具体：如果 `z2D_ori = 1`，那么 `z2U_new = 1`（从下变上）
  - 如果 `z2U_ori = 1`，那么 `z2D_new = 1`（从上变下）

## 修复方案

需要删除"情况1"和"情况2"（从水平变垂直或从垂直变水平），只保留"情况3"和"情况4"（改变方向）。

